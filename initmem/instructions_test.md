# Test instructions
Here are some sample programs that could test some instructions of the processor

### simple test

```
SW	x2, 0x06(x1)	
SW	x3, 0x0A(x1)	
ADD	x3, x1, x2	
LW	x6, 0x06(x1)	
BEQ	x4, x5, 0x12
```

### Immediate arithmetic instructions I

```
ADDI x6, x1, 10
ANDI x7, x2, 20
XORI x8, x3, 13
```

### Immediate arithmetic instructions II

```
ADDI x10, x1, 0x-64
SLL  x6, x1, x2
SRLI x7, x2, 0x01
SRAI x8, x3, 0x02
SLLI x9, x4, 0x05
SRAI x11, x10, 0x02
```

### Immediate arithmetic instructions III

```
ADDI  x10, x1, 0x-64
SLTI  x8, x2, 0x14
SLTIU x9, x3, 0x-0A
ADDI  x11, x2, 0x0C
SLLI  x12, x3, 0x04
SLT   x6, x10, x1
SLTU  x7, x10, x1
```

### Store instructions

```
SW    x20, x3, 0x00
SH    x21, x3, 0x04
SB    x22, x3, 0x08
```

### Load instructions

```
LW    x10, x0, 0x14
LHU   x11, x0, 0x18
LBU   x12, x0, 0x1C
LH    x13, x0, 0x14
LB    x14, x0, 0x18
```

### Jump and link instructions

```
JALR x6, x1, 0x0E
NOP
NOP
NOP
NOP
ADD x7, x1, x2
```

```
JAL  x6, 0x0A
NOP
NOP
NOP
NOP
AUIPC x7, 0xC2B
```

### RAW dependence test

```
ADDI x1, x0, 0x01
ADDI x2, x0, 0x02
ADDI x3, x0, 0x03
ADD x1, x1, x2
ADD x2, x1, x3
ADD x3, x1, x2
ADD x4, x1, x3
```

The correct status after running this program is:

- x1 = 0x03
- x2 = 0x06
- x3 = 0x09
- x4 = 0x0C

### simple program 1

The program is written in C:

```
void f()
{
    int a[5];
    for(int i = 0;i < 5;i++)
        a[i] = i + 1;
}
```

The assembly code represented by RV32I such as:

```
; x1 as the sp register, which indicate the address of array a
; x2 as the indicator i
; x3 as the upper bound 5

NOP
ADDI x3, x0, 0x05
ADDI x2, x2, 0x01
SW   x2, x1, 0x00
ADDI x1, x1, 0x04
BLT  x2, x3, 0x-06
NOP
NOP
```

The program above contains data hazard:

- x2: between ADDI and SW

This hazard could resolve by forward.

The correct status after running this program is:

- x1 = 0x14
- x2 = 0x05
- x3 = 0x05
- Mem[sp] ~ Mem[sp + 0x14] = 0x01 ~ 0x05

### data hazard test program

```
NOP
ADDI x1, x0, 0x0A
SW   x1, x0, 0x04
LW   x2, x0, 0x04
ADDI x3, x2, 0x10
ADD  x4, x1, x3
ADD  x5, x1, x3
NOP
NOP
```

The program above contains data hazards:

- x1: between ADDI and SW
- x2: between LW and ADDI
- x3: between ADDI and ADD(write x4 and x5)

The first and third data hazards could resolve by forward, the second data hazard must stall a cycle and then resolve by forward

### branch predict test I

```
NOP
ADDI x1, x0, 0x04
ADDI x2, x0, 0x08
BLT  x1, x2, 0x08
ADDI x1, x1, 0x01
BLT  x1, x2, 0x-04
BGE  x1, x2, 0x04
JALR x3, x0, 0x10
ADDI x1, x1, 0x01F
ADDI x2, x2, 0x0ED
NOP
NOP
```

### branch predict test II

```
NOP
ADDI x1, x0, 0x04
ADDI x2, x0, 0x08
JALR x3, x0, 0x14
ADDI x1, x1, 0x01
BLT  x1, x2, 0x-02
ADDI x1, x1, 0x1F
ADDI x2, x2, 0x2E
NOP
NOP
```

### A bubble sort example program

```
void f()
{
    int a[5], temp = 0;
    a[0] = 2;
    a[1] = 1;
    a[2] = 5;
    a[3] = 4;
    a[4] = 3;

    for(int i = 1;i < 5;i++)
    {
        for(int j = i;j > 0;j--)
        {
            if(a[j] < a[j-1])
            {
                temp = a[j];
                a[j] = a[j-1];
                a[j-1] = temp;
            }
        }
    }
}
```

The assembly code is not generated by the compiler, it is written by myself. So the code is not optimal.

```
; sp = x1 = 0x20
; x2 = i, x3 = j, x4 = temp
; x5 = a[j], x6 = a[j-1]
; x7 = indicator = 1
; x8 = a[j].addr, x9 = a[j-1].addr
; x10 = indicator = 4, x11 = counter_index, x12 = indicator = 5

NOP
ADDI    x1, x0, 0x20
ADDI    x7, x0, 0x01
ADDI    x10, x0, 0x01
SW      x10, x1, 0x04
ADDI    x10, x10, 0x01
SW      x10, x1, 0x00
ADDI    x10, x10, 0x01
SW      x10, x1, 0x10
ADDI    x10, x10, 0x01
SW      x10, x1, 0x0C
ADDI    x10, x10, 0x01
SW      x10, x1, 0x08
ADDI    x10, x0, 0x03
ADDI    x12, x0, 0x05
ADDI    x2, x0, 0x01
ADD     x3, x0, x2
ADDI    x11, x0, 0x00
ADD     x8, x0, x3
ADD     x8, x8, x3
ADDI    x11, x11, 0x01
BLT     x11, x10, 0x-04
ADDI    x9, x8, 0x-04
ADD     x8, x8, x1
ADD     x9, x9, x1
LW      x5, x8, 0x00
LW      x6, x9, 0x00
BGE     x5, x6, 0x08
ADD     x4, x0, x5
ADD     x5, x0, x6
ADD     x6, x0, x4
SW      x5, x8, 0x00
SW      x6, x9, 0x00
ADDI    x3, x3, 0x-01
BGE     x3, x7, 0x-22
ADDI    x2, x2, 0x01
BLT     x2, x12, 0x-28
NOP
NOP
```